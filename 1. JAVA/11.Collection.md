

# JAVA
___________________________________________________________________________________________________________________________________________________________________________________
### Collection 컬렉션

##### 컬렉션

	메모리상에서 자료를 구조적으로 처리하는 방법을 자료구조라 하는데,
	컬렉션은 자바에서 제공하는 자료구조를 담당하는 프레임워크.
	추가, 삭제, 정렬등의 기능처리가 간단하게 해결 되어 자료구조적 알고리즘을 구현할
	필요 없음
	java.util 패키지에 포함되며, 인터페이스를 통해 정형화된 방법으로 다양한
	컬렉션 클래스 이용 가능
	
##### 자료구조

	데이터(자료)를 메모리에서 구조적으로 처리하는 방법론
![자료구조](/images/자료구조.PNG)

##### 배열의 문제점 & 컬렉션의 장점

	- 배열의 문제점
	1. 한 번 크기를 지정하면 변경할 수 없다.
	2. 기록된 데이터에 대한 중간 위치의 추가, 삭제가 불편하다.
	3. 한 타입의 데이터만 저장 가능하다.
	
	- 컬렉션의 장점
	1. 저장하는 크기의 제약이 없다.
	2. 추가, 삭제, 정렬 등의 기능 처리가 간단하게 해결되낟.
	3. 여러 타입의 데이터가 저장 가능하다.

##### 컬렉션의 주요 인터페이스
![컬렉션](/images/컬렉션.PNG)

##### List

	자료들은 순차적으로 나열한 자료구조로 인덱스로 관리되며, 중복해서 객체 저장 가능
	구현 클래스로 ArrayList와 Vector, LinkedList가 있음
![리스트](/images/리스트.PNG)

##### ArrayList

	List의 후손으로 초기 저장용량은 10으로 자동 설정(따로 설정 가능)
	저장 용량을 초과한 객체들이 들어오면 자동 증가(고정도 가능)
	동기화(Synchronized)를 제공하지 않음
	* 동기화: 하나의 자원(데이터)에 대해 여러 쓰레드가 접근 하려 할 때 한 시점에서
				하나의 쓰레드만 사용할 수 있도록 하는 것

##### Vector

	List의 후손으로 ArrayList와 동등하지만 동기화(Synchromized)를
	제공한다는 점이 ArrayList와의 차이점
	-> List 객체들 중에서 가장 성능이 좋지 않음

##### LinkedList

	List의 후손으로, 인접 참조를 링크해 체인처럼 관리.
	특정 인덱스에서 객체를 제거하거나 추가하게 되면 바로 앞/뒤 링크만 변경하면 되기
	때문에 객체 삭제와 삽입이 빈번하게 일어나는 곳에서는 ArrayList보다
	성능이 좋다.
	
##### Comparable, Comparator, Collections.sort()
![컴파](/images/컴파.PNG)

##### Set

	저장 순서가 유지되지 않고, 중복 객체도 저장하지 못하게 하는 자료 구조
	null도 중복을 허용하지 않기 때문에 1개의 null만 저장
	구현 클래스로 HashSet, LinkedSet, TreeSet이 있음

##### HashSet, LinkedHashSet

	- HashSet
	Set에 객체를 저장할 때 hash함수를 사용하여 처리 속도가 빠름.
	동일 객체 뿐 아니라 동등 객체도 중복하여 저장하지 않음
	
	- LinkedHashSet
	HashSet과 거의 동일하지만 Set에 추가되는 순서를 유지한다.
	
##### Enumeration, Iterator, ListIterator

	컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스
	- Enumeration: Iterator의 구버전
	- ListIterator: Iterator를 상속받아 양방향 특징
	* iterator()메소드는 List와 Set계열에서만 사용
	
##### Map

	key와 value로 구성되어 있으며, 키와 같은 값은 모두 객체
	키는 중복 저장을 허용하지 않고, 값은 중복 저장 가능
	키가 중복되는 경우 기존에 있는 키에 해당하는 값을 덮어 씌움

##### HashMap

	키 객체는 hashCode()와 equals()를 재정의해 동등 객체가 될 조건을
	정해야 함, 때문에 키 타입은 hashCode와 equals()메소드가 재정의되어
	있는 String 타입을 주로 사용
	
##### Hashtable

	키 객체 만드는 법은 HashMap과 동일하나 쓰레드 동기화가 된 상태이기 때문에
	복수의 스레드가 동시에 Hashtable에 접근해 객체를 추가, 삭제 하더라도
	쓰레드에 안전
	
##### Properties

	키와 벨류를 String타입으로 제한한 Map컬렉션
	주로 Properties는 프로퍼티 파일을 읽어 들일 때 주로 사용한다.
	
	* 프로퍼티(*.properties)파일
	- 옵션정보, 데이터베이스 연결정보, 국제화(다국어)정보를 기록하여
		텍스트 파일로 활욜
	- 애플리케이션에서 주로 변경이 잦은 문자열을 저장하여 관리하기 때문에
		유지보수를 편리하게 만들어 줌
	- 키와 벨류값이 '='기호로 연결되어 있는 텍스트 파일로 ISO8859-1
		문자셋으로 저장되고, 한글은 유니코드로 변환되어 저장

##### TreeSet, TreeMap

	검색 기능을 강화시킨 컬렉션으로, 계층 구조를 활용해 이진 트리 자료구조를
	구현하여 제공
	
	- TreeSet
	이진 트리를 기반으로 한 Set컬렉션으로, 왼쪽과 오른쪽 자식 노드를 참조하기
	위한 두 개의 변수로 구성
	
	- TreeMap
	이진 트리를 기반으로 한 Map 컬렉션으로, 키와 벨류가 저장된 Map.Entry를
	저장하고 왼쪽과 오른쪽 자식 노드를 참조하기 위한 두 개의 변수로 구성
	
	* 정렬
	오름차순(기본 정렬)
	- TreeSet의 객체와 TreeMap의 key는 저장과 동시에 자동으로 오름차순 정렬
	- 숫자(Integer, Double)타입일 경우 값으로 정렬
	- 문자열(String)타입일 경우 유니코드로 정렬
	- 정렬을 위해 java.lang.Comparable을 구현한 객체 요구 그러지 않을
		경우 ClassCastException발생
	- Integer,Double,String 모두 Comparable 인터페이스를 통해
		오름차순이 구현되어 있음
		
	내림차순(따로 구현)
	- TreeSet, TreeMap 생성 시 배개변수 생성자를 통해 재정렬 가능
	ex) TreeMap<K,V> m 
			= new TreeMap(Comparator<? super K> comparator);
	- 숫자, 문자열 타입을 제외한 Comparable을 상속 받는 객체인 경우
	compareTo()메소드의 오버라이딩 부분을 내림차순으로 변경
	
##### Stack

	후입선출(LIFO: Last In First Out)구조로 JVM Stack메모리가
	Stack구조로 되어 있음
	
##### Queue

	선입선출(FIFO: First In First Out)구조로 작업 큐나 메세지 큐가
	Queue구조로 되어 있음
	
##### Deque

	큐와 스택의 성질을 모두 가지고 있는 구조로 검색과 같은 반복적인 문제에 특히
	유용한 데이터 구조










	
